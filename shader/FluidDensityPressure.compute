#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Smooth Kernel 관련 Uniform Variables
uniform float h;
uniform float hSquare;

uniform float particleMass;
uniform uint TotalParticleCount;

uniform float gasCoeffi;
uniform float restDensity;


// visible 정할 때, 보정 값
uniform float correction;



#define PI 3.1415
/* 
    W_poly6 -> 변수인 r 의 제곱을 사용한다
    사용처
        : 밀도 계산
*/
float W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9.0) ) ) * pow(abs(hSquare - r2), 3); }


/*
    입력 : Core Particle Buffer
        정렬된 버퍼
        파티클 ~ 카메라 거리, toCamera 값으로 정렬
        Far -> Near 순서로 정렬

    [Core Particle]           [Particle]

    xpos, ypos, zpos          position

    xvel, yvel, zvel          velocity

    -                 =>      range           , Update_Range
    -                 =>      density         , Update_Density_Pressure
    -                         pressure        , Update_Density_Pressure

                              
    -                         -
    toCamera ~> 버리고
    visible  ~> 버리고
                              neighbor 체크
 */
struct CoreParticle
{
    float xpos;
    float ypos;
    float zpos;

    float xvel;
    float yvel;
    float zvel;

    float toCamera;

    uint visible;
};

layout(std430, binding = 1) buffer CoreParticleBuffer
{
    CoreParticle cData[];
};


struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    // vec3 surfNormal;
    // float surfForceMag;

    vec3 force;
    //uint neighbor;
    float neighbor;
};

layout(std430, binding = 2) buffer ParticleBuffer
{
    Particle pData[];
};


/* 
    range 값 구하기
    SPH 기법 ==> 주변 particle 의 값을 이용해서 자신의 값을 구한다
    현재 input 은 정렬되어 있는 상태니까, 좌로 or 우로 검색하면서 영향력이 있는 거리내에 있는 particles 만 찾는다

    range -> 카메라로 부터 떨어진 거리를 이용
        현재 파티클로 부터 h 거리 떨어진 다른 파티클을 정확하게 알 수는 없지만
        그래도 최소한 절대 영향을 끼치지 않을 범위는 알 수 있다
        그 최소, 확률이 아예 제로인 영역을 제외하는 작업

    즉, range = 가능성이 있는 인덱스 범위
 */



void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint index = gl_GlobalInvocationID.x;

    // update position
    pData[index].position = vec4( cData[index].xpos, cData[index].ypos, cData[index].zpos, 1.0 );

    // update velocity
    pData[index].velocity = vec4( cData[index].xvel, cData[index].yvel, cData[index].zvel, 0.0 );





    // 각 방향별로 영향을 주는 particle 이 있었는 지 확인한다
    uint plusX = 0, plusZ = 0, plusY = 0;
    uint minusX = 0, minusZ = 0;

    // visible 에 영향을 주는 범위는 smooth kernel radius 와는 또 다르게 설정하자
    uint visibleFar     = index;
    uint visibleNear    = index;



    uint PossibleFar  = index;        // 가능성이 있는 영역의 파티클 중, 카메라에서 가장 멀리 있는 파티클 인덱스
    uint PossibleNear = index;        // 가능성이 있는 영역의 파티클 중, 카메라에서 가장 가까이 있는 파티클 인덱스
    
    // index => 0 검색, Current Particle 보다 멀리 있는 Particles 를 조사한다
    for(uint farId = index; farId >= 0; farId--)
    {
        // visible check
        vec3 meToNei = vec3(cData[farId].xpos, cData[farId].ypos, cData[farId].zpos)
                        - vec3(cData[index].xpos, cData[index].ypos, cData[index].zpos);

        // 이웃 파티클이 어느정도 가까이 있으면, visible 체크에 사용
        if(length(meToNei) < 2 * h)
        {
            if(meToNei.x > 0) plusX  += (+meToNei.x - correction > 0) ? 1 : 0;
            if(meToNei.x < 0) minusX += (-meToNei.x - correction > 0) ? 1 : 0;

            if(meToNei.z > 0) plusZ  += (+meToNei.z - correction > 0) ? 1 : 0;
            if(meToNei.z < 0) minusZ += (-meToNei.z - correction > 0) ? 1 : 0;

            if(meToNei.y > 0) plusY  += (+meToNei.y - correction > 0) ? 1 : 0;
        }

        

        // range check
        // 검색 범위가 끝나면 종료
        if(farId == 0)
        {
            PossibleFar = 0;
            break;
        }
        if(cData[farId].toCamera >= cData[index].toCamera + h)    
            break;
        else
            PossibleFar = farId;
    }


    // index => particleCount 검색, Current Particle 보다 가까이 있는 Particles 를 조사한다
    if(cData[index].toCamera - h < 0)   // h 가 긴 경우 => 모든 파티클을 조사
    {
        for(uint nearId = index; nearId < TotalParticleCount; nearId++)
        {
            // visible check
            vec3 meToNei = vec3(cData[nearId].xpos, cData[nearId].ypos, cData[nearId].zpos)
                            - vec3(cData[index].xpos, cData[index].ypos, cData[index].zpos);

            // 이웃 파티클이 어느정도 가까이 있으면, visible 체크에 사용
            if(length(meToNei) < 2 * h)
            {
                if(meToNei.x > 0) plusX  += (+meToNei.x - correction > 0) ? 1 : 0;
                if(meToNei.x < 0) minusX += (-meToNei.x - correction > 0) ? 1 : 0;

                if(meToNei.z > 0) plusZ  += (+meToNei.z - correction > 0) ? 1 : 0;
                if(meToNei.z < 0) minusZ += (-meToNei.z - correction > 0) ? 1 : 0;

                if(meToNei.y > 0) plusY  += (+meToNei.y - correction > 0) ? 1 : 0;
            }
        }

        PossibleNear = TotalParticleCount - 1;
    }
    else
    {
        for(uint nearId = index; nearId < TotalParticleCount; nearId++)
        {
            // visible check
            vec3 meToNei = vec3(cData[nearId].xpos, cData[nearId].ypos, cData[nearId].zpos)
                            - vec3(cData[index].xpos, cData[index].ypos, cData[index].zpos);

            // 이웃 파티클이 어느정도 가까이 있으면, visible 체크에 사용
            if(length(meToNei) < 2 * h)
            {
                if(meToNei.x > 0) plusX  += (+meToNei.x - correction > 0) ? 1 : 0;
                if(meToNei.x < 0) minusX += (-meToNei.x - correction > 0) ? 1 : 0;

                if(meToNei.z > 0) plusZ  += (+meToNei.z - correction > 0) ? 1 : 0;
                if(meToNei.z < 0) minusZ += (-meToNei.z - correction > 0) ? 1 : 0;

                if(meToNei.y > 0) plusY  += (+meToNei.y - correction > 0) ? 1 : 0;
            }


            if(cData[nearId].toCamera <= cData[index].toCamera - h)
                break;
            else
                PossibleNear = nearId;
        }
    }

    // visible 여부 저장
    // 한 방향이라도 상대 파티클이 없으면 0 이 저장된다
    // 한 방향이라도 상대 파티클이 없으면 외부이다
    // 즉 0 이면 외부이다 = 0 이면 visible 하다
    pData[index].neighbor = (plusX & minusX & plusZ & minusZ & plusY);




    /* 
        update range
            x => far, y => near
     */
    pData[index].range.x = PossibleFar;
    pData[index].range.y = PossibleNear;






    float newDensity = 0.0;     // 새로운 밀도
    float newPressure = 0.0;    // 새로운 압력


    /* 
        자기 자신이 검색 대상에 포함되어
            particle 스스로의 질량으로 density 와 pressure 를 만들어 낸다
        
        앞서 업데이트한 range 를 이용해서 검색한다
            그래도 디테일한 확인은 해야 한다

        Far index -> Near index 로 검색
            인덱스 증가
     */
    for(uint neId = pData[index].range.x; neId <= pData[index].range.y; neId++)
    {
        // 내가 상대 파티클을 바라보는 벡터
        vec3 relativePos = vec3(cData[neId].xpos, cData[neId].ypos, cData[neId].zpos) - vec3(cData[index].xpos, cData[index].ypos, cData[index].zpos);
        float rSquare = dot(relativePos, relativePos);

        // 실제 영향 여부는 직접 체크해야 한다
        if(rSquare < hSquare)
        {
            newDensity += particleMass * W_Poly6(rSquare);
            
            // 자기 자신에 대해서 계산하는, 0 벡터는 계산에서 제외
            if(neId != index)
            {
                // 각 방향별로 상대 파티클의 위치의 성분을 확인하고 더한다
                //plusX  += dot(vec3(+1, 0, 0), relativePos);
                //minusX += dot(vec3(-1, 0, 0), relativePos);
                //plusX  += 1;
                
            }
        }
    }

    // 새롭게 구한 밀도 -> 새로운 압력 구함
    newPressure = gasCoeffi * max(newDensity - restDensity, 0.0);


    // Update
    pData[index].density  = newDensity;
    pData[index].pressure = newPressure;
    


}