#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Smooth Kernel 관련 Uniform Variables
uniform float h;
uniform float hSquare;

uniform float particleMass;
uniform uint TotalParticleCount;

uniform float gasCoeffi;
uniform float restDensity;



#define PI 3.1415
/* 
    W_poly6 -> 변수인 r 의 제곱을 사용한다
    사용처
        : 밀도 계산
*/
float W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9.0) ) ) * pow(abs(hSquare - r2), 3); }


/*
    카메라로부터 떨어진 거리를 기준으로 정렬된 배열을 input 으로 받는다
        좌, 우를 한번 훑기만 해도 smooth radius 내의 파티클들을 모두 찾을 수 있다

    position, velocity 는 그대로 input -> output 으로 전달
    각 particle 의 밀도와 압력은 계산을 한뒤 -> output 에 저장
 */

struct Particle
{
    vec4 Position;
    vec4 Velocity;
    vec4 force;
    vec4 surfNormal;
    float density;
    float pressure;
    float ToCamera;
    float padding;
};

layout(std430, binding = 1) buffer InputBuffer
{
    Particle inputData[];
};

layout(std430, binding = 2) buffer OutputBuffer
{
    Particle outputData[];
};



/* 
    여기서는 Particle 의 내부 값들을 업데이트
        다른 Particle 의 상태를 읽어야 하기 떄문에, 정렬된 input 이 필요하다
    
    input data 의
        Position
        Velocity
        ToCamera

        값들을 사용한다
 */
void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint Index = gl_GlobalInvocationID.x;

    // 3. 밀도 => 매번 새롭게 구한다
    float newDensity = 0.0;
        // SPH 기법 ==> 주변 particle 의 값을 이용해서 자신의 값을 구한다
        // 현재 input 은 정렬되어 있는 상태니까, 좌로 or 우로 검색하면서 영향력이 있는 거리내에 있는 particles 만 찾는다

        uint RelativeFar  = Index;
        uint RelativeNear = Index;
    

        // Index => 0 검색, Particle 보다 멀리 있는 Particles 를 조사한다
        for(uint farId = Index; farId >= 0; farId--)
        {
            if(farId == 0)
            {
                RelativeFar = 0;
                break;
            }

            if(inputData[farId].ToCamera > inputData[Index].ToCamera + h)
                break;
            else
                RelativeFar = farId;
        }
            

        // Index => particleCount 검색, Particle 보다 가까이 있는 Particles 를 조사한다
        if(inputData[Index].ToCamera - h < 0)
            RelativeNear = TotalParticleCount - 1;
        else
        {
            for(uint nearId = Index; nearId < TotalParticleCount; nearId++)
            {
                if(inputData[nearId].ToCamera < inputData[Index].ToCamera - h)
                    break;
                else
                    RelativeNear = nearId;
            }
        }
        
        /* 
            자기 자신이 검색 대상에 포함된다
            particle 스스로의 질량으로 density 와 pressure 를 만들어 낸다
         */
        for(uint id = RelativeFar; id <= RelativeNear; id++)
        {
            vec3 relativePos = inputData[Index].Position.xyz - inputData[id].Position.xyz;
            float rSquare = dot(relativePos, relativePos);

            if(rSquare < hSquare) // Get In
                newDensity += particleMass * W_Poly6(rSquare);
        }
    outputData[Index].density = newDensity;

    // density -> pressure 계산, 논문에서 사용한 수정된 이상기체 방정식을 이용
    outputData[Index].pressure = gasCoeffi * max(newDensity - restDensity, 0.0f);
    
    // 0. ToCamera => 카메라까지의 거리를 전달
    outputData[Index].ToCamera = inputData[Index].ToCamera;


    // 1. Position => 그대로 전달
    outputData[Index].Position = inputData[Index].Position;


    // 2. Velocity => 그대로 전달
    outputData[Index].Velocity = inputData[Index].Velocity;
}

// force, pressure 를 제외한 모든 데이터 입력 완료