#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Smooth Kernel 관련 Uniform Variables
uniform float h;
uniform float hSquare;

uniform float particleMass;
uniform uint TotalParticleCount;

uniform float gasCoeffi;
uniform float restDensity;



#define PI 3.1415
/* 
    W_poly6 -> 변수인 r 의 제곱을 사용한다
    사용처
        : 밀도 계산
*/
float W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9.0) ) ) * pow(abs(hSquare - r2), 3); }


/*
    입력 : Core Particle Buffer
        정렬된 버퍼
        파티클 ~ 카메라 거리, toCamera 값으로 정렬
        Far -> Near 순서로 정렬

    [Core Particle]           [Particle]

    xpos, ypos, zpos          position

    xvel, yvel, zvel          velocity

    -                 =>      range           , Update_Range
    -                 =>      density         , Update_Density_Pressure
    -                         pressure        , Update_Density_Pressure

                              -
                              -
                              
    -
    toCamera                  toCamera
 */
struct CoreParticle
{
    float xpos;
    float ypos;
    float zpos;

    float xvel;
    float yvel;
    float zvel;

    float toCamera;

    float isSurf;
};

layout(std430, binding = 1) buffer CoreParticleBuffer
{
    CoreParticle cData[];
};


struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 surfNormal;
    float surfForceMag;

    vec3 force;
    float toCamera;
};

layout(std430, binding = 2) buffer ParticleBuffer
{
    Particle pData[];
};


/* 
    range 값 구하기
    SPH 기법 ==> 주변 particle 의 값을 이용해서 자신의 값을 구한다
    현재 input 은 정렬되어 있는 상태니까, 좌로 or 우로 검색하면서 영향력이 있는 거리내에 있는 particles 만 찾는다

    range -> 카메라로 부터 떨어진 거리를 이용
        현재 파티클로 부터 h 거리 떨어진 다른 파티클을 정확하게 알 수는 없지만
        그래도 최소한 절대 영향을 끼치지 않을 범위는 알 수 있다
        그 최소, 확률이 아예 제로인 영역을 제외하는 작업

    즉, range = 가능성이 있는 인덱스 범위
 */



void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint index = gl_GlobalInvocationID.x;

    // update position
    pData[index].position = vec4( cData[index].xpos, cData[index].ypos, cData[index].zpos, 1.0 );

    // update velocity
    pData[index].velocity = vec4( cData[index].xvel, cData[index].yvel, cData[index].zvel, 0.0 );

    // update toCamera
    pData[index].toCamera = cData[index].toCamera;



    uint PossibleFar  = index;        // 가능성이 있는 영역의 파티클 중, 카메라에서 가장 멀리 있는 파티클 인덱스
    uint PossibleNear = index;        // 가능성이 있는 영역의 파티클 중, 카메라에서 가장 가까이 있는 파티클 인덱스
    
    // index => 0 검색, Current Particle 보다 멀리 있는 Particles 를 조사한다
    for(uint farId = index; farId >= 0; farId--)
    {
        if(farId == 0)
        {
            PossibleFar = 0;
            break;
        }

        if(cData[farId].toCamera >= cData[index].toCamera + h)    
            break;
        else
            PossibleFar = farId;
    }


    // index => particleCount 검색, Current Particle 보다 가까이 있는 Particles 를 조사한다
    if(cData[index].toCamera - h < 0)   // h 가 긴 경우 => 모든 파티클을 조사
        PossibleNear = TotalParticleCount - 1;
    else
    {
        for(uint nearId = index; nearId < TotalParticleCount; nearId++)
        {
            if(cData[nearId].toCamera <= cData[index].toCamera - h)
                break;
            else
                PossibleNear = nearId;
        }
    }


    /* 
        update range
            x => far, y => near
     */
        pData[index].range.x = PossibleFar;
        pData[index].range.y = PossibleNear;



    float newDensity = 0.0;     // 새로운 밀도
    float newPressure = 0.0;    // 새로운 압력

    /* 
        자기 자신이 검색 대상에 포함되어
            particle 스스로의 질량으로 density 와 pressure 를 만들어 낸다
        
        앞서 업데이트한 range 를 이용해서 검색한다
            그래도 디테일한 확인은 해야 한다

        Far index -> Near index 로 검색
            인덱스 증가
     */
    for(uint neId = pData[index].range.x; neId <= pData[index].range.y; neId++)
    {
        vec3 relativePos = vec3(cData[index].xpos, cData[index].ypos, cData[index].zpos) - vec3(cData[neId].xpos, cData[neId].ypos, cData[neId].zpos);

        float rSquare = dot(relativePos, relativePos);

        if(rSquare < hSquare)       // 실제 영향 여부는 직접 체크해야 한다
            newDensity += particleMass * W_Poly6(rSquare);
    }

    // 새롭게 구한 밀도 -> 새로운 압력 구함
    newPressure = gasCoeffi * max(newDensity - restDensity, 0.0);


    // Update
    pData[index].density  = newDensity;
    pData[index].pressure = newPressure;
}