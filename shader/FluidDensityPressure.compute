#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Smooth Kernel 관련 Uniform Variables
uniform float h;
uniform float hSquare;

uniform float particleMass;
uniform uint TotalParticleCount;

uniform float gasCoeffi;
uniform float restDensity;



#define PI 3.1415
/* 
    W_poly6 -> 변수인 r 의 제곱을 사용한다
    사용처
        : 밀도 계산
*/
float W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9.0) ) ) * pow(abs(hSquare - r2), 3); }


/*
    정렬된 배열 ParticleBuffer 입력 상황
        파티클 ~ 카메라 거리, toCamera 값으로 정렬
        Far -> Near 순서로 정렬

    position;                  position

    velocity;                  velocity

    -                       =>      range           , Update_Range
    -                       =>      density         , Update_Density_Pressure
    -                               pressure        , Update_Density_Pressure

    -
    toCamera;                 toCamera
 */

struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 force;
    float toCamera;
};

layout(std430, binding = 1) buffer ParticleBuffer
{
    Particle pData[];
};


/* 
    range 값 구하기
    SPH 기법 ==> 주변 particle 의 값을 이용해서 자신의 값을 구한다
    현재 input 은 정렬되어 있는 상태니까, 좌로 or 우로 검색하면서 영향력이 있는 거리내에 있는 particles 만 찾는다

    range -> 카메라로 부터 떨어진 거리를 이용
        현재 파티클로 부터 h 거리 떨어진 다른 파티클을 정확하게 알 수는 없지만
        그래도 최소한 절대 영향을 끼치지 않을 범위는 알 수 있다
        그 최소, 확률이 아예 제로인 영역을 제외하는 작업

    즉, range = 가능성이 있는 인덱스 범위
 */
void Update_Range(uint myId)
{
    uint PossibleFar  = myId;        // 가능성이 있는 영역의 파티클 중, 카메라에서 가장 멀리 있는 파티클 인덱스
    uint PossibleNear = myId;        // 가능성이 있는 영역의 파티클 중, 카메라에서 가장 가까이 있는 파티클 인덱스
    
    
    // myId => 0 검색, Current Particle 보다 멀리 있는 Particles 를 조사한다
    for(uint farId = myId; farId >= 0; farId--)
    {
        if(farId == 0)
        {
            PossibleFar = 0;
            break;
        }

        if(pData[farId].toCamera >= pData[myId].toCamera + h)    
            break;
        else
            PossibleFar = farId;
    }


    // myId => particleCount 검색, Current Particle 보다 가까이 있는 Particles 를 조사한다
    if(pData[myId].toCamera - h < 0)   // h 가 긴 경우 => 모든 파티클을 조사
        PossibleNear = TotalParticleCount - 1;
    else
    {
        for(uint nearId = myId; nearId < TotalParticleCount; nearId++)
        {
            if(pData[nearId].toCamera <= pData[myId].toCamera - h)
                break;
            else
                PossibleNear = nearId;
        }
    }


    /* 
        Update

        x => far
        y => near
     */
    pData[myId].range.x = PossibleFar;
    pData[myId].range.y = PossibleNear;
}


void Update_Density_Pressure(uint myId)
{    
    float newDensity = 0.0;     // 새로운 밀도
    float newPressure = 0.0;    // 새로운 압력

    /* 
        자기 자신이 검색 대상에 포함되어
            particle 스스로의 질량으로 density 와 pressure 를 만들어 낸다
        
        앞서 업데이트한 range 를 이용해서 검색한다
            그래도 디테일한 확인은 해야 한다

        Far index -> Near index 로 검색
            인덱스 증가
     */
    for(uint neId = pData[myId].range.x; neId <= pData[myId].range.y; neId++)
    {
        vec3 relativePos = pData[myId].position.xyz - pData[neId].position.xyz;
        float rSquare = dot(relativePos, relativePos);

        if(rSquare < hSquare)       // 실제 영향 여부는 직접 체크해야 한다
            newDensity += particleMass * W_Poly6(rSquare);
    }

    // 새롭게 구한 밀도 -> 새로운 압력 구함
    newPressure = gasCoeffi * max(newDensity - restDensity, 0.0);


    // Update
    pData[myId].density  = newDensity;
    pData[myId].pressure = newPressure;
}



void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint index = gl_GlobalInvocationID.x;

    Update_Range(index);
    Update_Density_Pressure(index);
}