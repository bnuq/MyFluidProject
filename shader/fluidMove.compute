#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


/*
    position                    new position

    velocity                    new velocity

    range                       
    density                     
    pressure                    

    force                   

    toCamera                    new toCamera
                                    position 이 바뀌었으니까
                                    새로 구해줘야지
 */

struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 force;
    float toCamera;
};


layout(std430, binding = 1) buffer ParticleBuffer
{
    Particle pData[];
};


uniform float deltaTime;

uniform vec3 LimitRange;
uniform float damping;

uniform vec3 CameraPos;



/* 
    한 파티클의 내용을 업데이트 하는 과정
    다른 파티클의 데이터를 읽지도 않고, 필요로 하지도 않는다

    1. Particle 의 속도에 맞게 이동시키기
        Make_Move(index)

    2. 범위를 벗어나는 지 확인하고, 벗어나는 경우 되돌리기
        Check_Range(index)

    3. 최종 위치로부터 카메라까지의 거리 구하기
        Get_Camera_Distance(index)
 */



// 지금까지 사용해왔던, output data 에 저장된 ToCamera 값 대신 새로운 값을 갱신
void Get_Camera_Distance(uint idx)
{
    Particle curParticle = pData[idx];
        

    pData[idx] = curParticle;
}

void main()
{
    // 동일하게 하나의 그룹은 x 축 방향만 가지고 있고, x 축 방향 그룹만 존재한다고 생각
    uint index = gl_GlobalInvocationID.x;


    // velocity update
    pData[index].velocity.xyz += deltaTime * (pData[index].force.xyz / pData[index].density);
    // position update
    pData[index].position.xyz += deltaTime * pData[index].velocity.xyz;

    
    // 경계 체크
    // 경계를 벗어난 파티클 => 돌아가야 하는 경계를 가리키는 벡터
    vec3 OverVec = vec3(0, 0, 0);

    // 경계를 벗어난 경우를 찾고, 그에 맞게 돌아가야 하는 방향을 찾는다
    if     (pData[index].position.x < -LimitRange.x)       OverVec.x += -LimitRange.x - pData[index].position.x;
    else if(pData[index].position.x > +LimitRange.x)       OverVec.x += +LimitRange.x - pData[index].position.x;
    
    if     (pData[index].position.y < -LimitRange.y)       OverVec.y += -LimitRange.y - pData[index].position.y;
    else if(pData[index].position.y > +LimitRange.y)       OverVec.y += +LimitRange.y - pData[index].position.y;

    if     (pData[index].position.z < -LimitRange.z)       OverVec.z += -LimitRange.z - pData[index].position.z;
    else if(pData[index].position.z > +LimitRange.z)       OverVec.z += +LimitRange.z - pData[index].position.z;

    // 들어오는 벡터가 0 이 아닌 경우 => 벗어남이 존재한다
    if(length(OverVec) != 0)
    {
        pData[index].velocity.xyz = normalize(OverVec) * damping;   // 속도를 강제로 들어오는 방향으로 설정
        pData[index].position.xyz += (1.00001) * OverVec;;           // 위치를 강제로 영역 내부로 넣어버린다
    }


    // 최종 위치를 이용해서, 파티클에서 카메라까지 거리를 구한다
    pData[index].toCamera = distance(CameraPos, pData[index].position.xyz);
}