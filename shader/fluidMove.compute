#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;



uniform float deltaTime;

uniform vec3 LimitRange;
uniform float damping;

uniform vec3 CameraPos;



/*
    [Particle]                  [Core Particle]

    position                    new position

    velocity                    new velocity

    range                       
    density                     
    pressure                    

    force                   
    neighbor                    
                                new toCamera
                                -
 */
struct CoreParticle
{
    float xpos;
    float ypos;
    float zpos;

    float xvel;
    float yvel;
    float zvel;

    float toCamera;

    uint visible;
};
layout(std430, binding = 1) buffer CoreParticleBuffer
{
    CoreParticle cData[];
};



struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 force;
    uint neighbor;
};
layout(std430, binding = 2) buffer ParticleBuffer
{
    Particle pData[];
};



void main()
{
    // 동일하게 하나의 그룹은 x 축 방향만 가지고 있고, x 축 방향 그룹만 존재한다고 생각
    uint index = gl_GlobalInvocationID.x;


    // 일단 속도, 위치를 변화시키고
    pData[index].velocity.xyz += deltaTime * (pData[index].force.xyz / pData[index].density);
    pData[index].position.xyz += deltaTime * pData[index].velocity.xyz;


    // 경계 체크 => 속도, 위치를 적적하게 변화시킨다
    // 경계를 벗어난 파티클 => 돌아가야 하는 경계를 가리키는 벡터
    vec3 OverVec = vec3(0, 0, 0);

    // 경계를 벗어난 경우를 찾고, 그에 맞게 돌아가야 하는 방향을 찾는다
    // 경계 = (0, 0, 0) ~ LimitRange
    if     (pData[index].position.x < 0)                    OverVec.x -= pData[index].position.x;
    else if(pData[index].position.x > LimitRange.x)         OverVec.x += LimitRange.x - pData[index].position.x;
    
    if     (pData[index].position.y < 0)                    OverVec.y -= pData[index].position.y;
    else if(pData[index].position.y > LimitRange.y)         OverVec.y += LimitRange.y - pData[index].position.y;

    if     (pData[index].position.z < 0)                    OverVec.z -= pData[index].position.z;
    else if(pData[index].position.z > LimitRange.z)         OverVec.z += LimitRange.z - pData[index].position.z;

    // 들어오는 벡터가 0 이 아닌 경우 => 벗어남이 존재한다
    if(length(OverVec) != 0)
    {
        pData[index].velocity.xyz = normalize(OverVec) * damping;    // 속도를 강제로 들어오는 방향으로 설정
        pData[index].position.xyz += (1.00001) * OverVec;            // 위치를 강제로 영역 내부로 넣어버린다
    }



    // 1. update position
    cData[index].xpos = pData[index].position.x;
    cData[index].ypos = pData[index].position.y;
    cData[index].zpos = pData[index].position.z;

    
    // 2. update velocity    
    cData[index].xvel = pData[index].velocity.x;
    cData[index].yvel = pData[index].velocity.y;
    cData[index].zvel = pData[index].velocity.z;


    // 3. update toCamera
    cData[index].toCamera = distance(CameraPos, pData[index].position.xyz);
}