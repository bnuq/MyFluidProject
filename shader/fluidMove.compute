#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


/*
    [Particle]                  [Core Particle]

    position                    new position

    velocity                    new velocity

    range                       
    density                     
    pressure                    

    surfNormal
    surfForceMag

    force                   

    toCamera                    new toCamera
                                    position 이 바뀌었으니까
                                    새로 구해줘야지

                                new isSurf
 */
struct CoreParticle
{
    float xpos;
    float ypos;
    float zpos;

    float xvel;
    float yvel;
    float zvel;

    float toCamera;

    float isSurf;
};

layout(std430, binding = 1) buffer CoreParticleBuffer
{
    CoreParticle cData[];
};


struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 surfNormal;
    float surfForceMag;

    vec3 force;
    float toCamera;
};

layout(std430, binding = 2) buffer ParticleBuffer
{
    Particle pData[];
};


layout(std430, binding = 5) buffer CountBuffer
{
    uint count;
};






uniform float deltaTime;

uniform vec3 LimitRange;
uniform float damping;

uniform vec3 CameraPos;


uniform float threshold;


/* 
    한 파티클의 내용을 업데이트 하는 과정
    다른 파티클의 데이터를 읽지도 않고, 필요로 하지도 않는다

    1. Particle 의 속도에 맞게 이동시키기
        Make_Move(index)

    2. 범위를 벗어나는 지 확인하고, 벗어나는 경우 되돌리기
        Check_Range(index)

    3. 최종 위치로부터 카메라까지의 거리 구하기
        Get_Camera_Distance(index)
 */




void main()
{
    // 동일하게 하나의 그룹은 x 축 방향만 가지고 있고, x 축 방향 그룹만 존재한다고 생각
    uint index = gl_GlobalInvocationID.x;


    pData[index].velocity.xyz += deltaTime * (pData[index].force.xyz / pData[index].density);
    pData[index].position.xyz += deltaTime * pData[index].velocity.xyz;


    // 경계 체크
    // 경계를 벗어난 파티클 => 돌아가야 하는 경계를 가리키는 벡터
    vec3 OverVec = vec3(0, 0, 0);

    // 경계를 벗어난 경우를 찾고, 그에 맞게 돌아가야 하는 방향을 찾는다
    if     (pData[index].position.x < -LimitRange.x)       OverVec.x += -LimitRange.x - pData[index].position.x;
    else if(pData[index].position.x > +LimitRange.x)       OverVec.x += +LimitRange.x - pData[index].position.x;
    
    if     (pData[index].position.y < -LimitRange.y)       OverVec.y += -LimitRange.y - pData[index].position.y;
    else if(pData[index].position.y > +LimitRange.y)       OverVec.y += +LimitRange.y - pData[index].position.y;

    if     (pData[index].position.z < -LimitRange.z)       OverVec.z += -LimitRange.z - pData[index].position.z;
    else if(pData[index].position.z > +LimitRange.z)       OverVec.z += +LimitRange.z - pData[index].position.z;

    // 들어오는 벡터가 0 이 아닌 경우 => 벗어남이 존재한다
    if(length(OverVec) != 0)
    {
        pData[index].velocity.xyz = normalize(OverVec) * damping;   // 속도를 강제로 들어오는 방향으로 설정
        pData[index].position.xyz += (1.00001) * OverVec;;           // 위치를 강제로 영역 내부로 넣어버린다
    }


    // update position
    cData[index].xpos = pData[index].position.x;
    cData[index].ypos = pData[index].position.y;
    cData[index].zpos = pData[index].position.z;
    
    // update velocity    
    cData[index].xvel = pData[index].velocity.x;
    cData[index].yvel = pData[index].velocity.y;
    cData[index].zvel = pData[index].velocity.z;

    // update toCamera
    cData[index].toCamera = distance(CameraPos, pData[index].position.xyz);



    /* 
        pData 에서 surface normal 를 확인 => 일정 크기 이상이면 cData 에 isSurf = 1.0 을 넣어준다
        
        그리고 surface 를 발견할 때마다 count 개수를 증가시켜, 총 surface 의 개수를 파악할 수 있게 한다
    */
    if( length(pData[index].surfNormal) > threshold )
    {
        cData[index].isSurf = 1.0f;
        atomicAdd(count, 1);
    }        
    else
        cData[index].isSurf = 0.0f;

}