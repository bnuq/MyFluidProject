#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


struct Particle
{
    vec4 Position;
    vec4 Velocity;
    vec4 force;
    vec4 surfNormal;
    float density;
    float pressure;
    float ToCamera;
    float padding;
};
layout(std430, binding = 1) buffer InputBuffer
{
    Particle inputData[];
};


layout(std430, binding = 2) buffer OutputBuffer
{
    Particle outputData[];
};


uniform float deltaTime;

uniform vec3 LimitRange;
uniform float damping;

uniform vec3 CameraPos;



/* 
    1. Particle 의 속도에 맞게 이동시키기
        Make_Move(index)

    2. 범위를 벗어나는 지 확인하고, 벗어나는 경우 되돌리기
        Check_Range(index)

    3. 최종 위치로부터 카메라까지의 거리 구하기
        Get_Camera_Distance(index)
 */

void Make_Move(uint idx)
{
    Particle curParticle = inputData[idx];
        // 속도 구하고
        curParticle.Velocity.xyz += deltaTime * (curParticle.force.xyz / curParticle.density);
        // 위치 구하고
        curParticle.Position.xyz += deltaTime * curParticle.Velocity.xyz;
    
    inputData[idx] = curParticle;
}

void Check_Range(uint idx)
{
    Particle curParticle = inputData[idx];

        // 파티클이 경계를 벗어난 경우, 다시 돌아가야 하는 내부를 향하는 노멀벡터
        vec3 norVec = vec3(0, 0, 0);
        // 파티클이 경계를 벗어난 경우, 벗어난 거리
        float overLength = 0;

        // 경계를 벗어난 경우를 찾고, 그에 맞게 돌아가야 하는 방향을 찾는다
        if     (curParticle.Position.x < -LimitRange.x)       norVec.x += -LimitRange.x - curParticle.Position.x;
        else if(curParticle.Position.x > +LimitRange.x)       norVec.x += +LimitRange.x - curParticle.Position.x;
        
        if     (curParticle.Position.y < -LimitRange.y)       norVec.y += -LimitRange.y - curParticle.Position.y;
        else if(curParticle.Position.y > +LimitRange.y)       norVec.y += +LimitRange.y - curParticle.Position.y;

        if     (curParticle.Position.z < -LimitRange.z)       norVec.z += -LimitRange.z - curParticle.Position.z;
        else if(curParticle.Position.z > +LimitRange.z)       norVec.z += +LimitRange.z - curParticle.Position.z;

        // 돌아가는 벡터가 0인 경우 == 파티클이 경계를 벗어나지 않았다 == 할 게 없다
        if(length(norVec) == 0) return;
        // 아니라면, 정해진 방향을 향하도록 속도를 바꾸고, 위치도 옮겨버린다
        else
        {
            curParticle.Velocity.xyz = norVec * damping;
            curParticle.Position.xyz += (1.001) * norVec;

            inputData[idx] = curParticle;
        }

}

void Get_Camera_Distance(uint idx)
{
    Particle curParticle = inputData[idx];
        curParticle.ToCamera = distance(CameraPos, curParticle.Position.xyz);

    inputData[idx] = curParticle;
}

void main()
{
    // 동일하게 하나의 그룹은 x 축 방향만 가지고 있고, x 축 방향 그룹만 존재한다고 생각
    uint Index = gl_GlobalInvocationID.x;

    // 1. 먼저 현재 조건 => 속도 구하고 => 이동한다
    Make_Move(Index);

    // 2. 정해진 경계를 벗어나는 지 확인한다
    Check_Range(Index);

    // 3. 파티클에서 카메라까지 거리를 구하낟
    Get_Camera_Distance(Index);
        
    // input data 에 저장해 놓은 값을 output 에 넣는다
    outputData[Index] = inputData[Index];
}