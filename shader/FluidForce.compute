#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


// 넘겨받는 Uniform Variables
// 0
    // Smooth Kernel 관련 정보
    uniform float h;
    uniform float hSquare;

    // Particles 에 대한 정보
    uniform float particleMass;
    uniform uint particleCount;

// 1
    // 점성에 의한 힘
    uniform float viscosity;

    // 표면 장력의 정도
    uniform float surfCoeffi;
    uniform float surfForceThreshold;

// 2 => Extra Force
    uniform vec4 gravityAcel;


uniform float pressureRatio;
uniform float viscosityRatio;
uniform float surfaceRatio;


    


    

    //smooth kernel 함수들 => 일단 함수로 쓰고, 나중에 MACRO 로 바꿔보자
    #define PI 3.1415
    /* 
        Grad_W_Poly6 -> r 제곱을 변수로 사용
                    -> gradient 결과 상대 particle 을 가리키는 벡터를 가진다
                    -> 이 함수는 크기만 계산
        사용처
            : surface normal filed pointing into the fluid 계산
    */
    float Grad_W_Poly6(float r2) { return (315.0 * (-6.0) / (64.0 * PI * pow(abs(h), 9))) * pow(abs(hSquare - r2), 2); }
    /* 
        Laplace_W_Poly6 -> r 제곱을 사용
        사용처
            : curvature of the surface 계산
    */
    float Laplace_W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9))) * ((-18) * pow(abs(hSquare - r2), 2) + 24 * r2 * (hSquare - r2)); }
    /* 
        Grad_W_Spiky -> r 을 사용
                    -> particle 에서 다른 particle 을 향하는 방향을 가진다 => normalized vector
                    -> 이 함수는 단위벡터를 제외한 크기만 계산
        사용처
            : 압력에 의한 힘 계산
    */
    float Grad_W_Spiky(float r) { return (-45.0 / ( PI * pow(abs(h), 6) )) * (pow(abs(h - r), 2)); }
    /* 
        Laplace_W_Viscosity -> r 사용
        사용처
            : 점성에 의한 힘 계산
    */
    float Laplace_W_Viscosity(float r) { return (45.0 / (PI * pow(abs(h), 6))) * (h - r); }





/* 
    Output Data 에서,
    Position, Velocity, density, pressure 는 계산이 완료된 상태

    force, surfNormal 을 구해서 넣어주어야 한다

    input data 가 그대로 output 으로 들어왔기 때문에, particles 는 여전히 정렬된 상태다
 */
struct Particle
{
    vec4 Position;
    vec4 Velocity;
    vec4 force;
    vec4 surfNormal;
    float density;
    float pressure;
    float ToCamera;
    float padding;
};
layout(std430, binding = 2) buffer OutputBuffer
{
    Particle outputData[];
};

layout(std430, binding = 5) buffer TestBuffer
{
    uint count;
};



/* 
    force(알짜힘) + surfNormal 구하기
        0. 가장 먼저 surfNormal 을 구한다

        1. 주변 particles 의 값을 통해 구하는 값
            압력에 의한 힘
            점성에 의한 힘
            표면장력

        2. 주변과 관계없이 구할 수 있는 값
            wave
            중력
            클릭
 */


// 0. 가장 먼저 surfNormal 구하기
void Update_SurfNormal(uint idx)
{
    vec4 newSurfNormal = vec4(0.0, 0.0, 0.0, 0.0);

        // 좌 검색
        for(uint otherId = idx - 1; otherId >= 0; otherId--)
        {
            // 다른 파티클~카메라 까지 거리가, 내 카메라까지 거리 - h 보다 작으면, 그 이후부턴 무조건 멀다
            if(outputData[otherId].ToCamera < outputData[idx].ToCamera - h)
                break;

            // 두 파티클 사이의 거리를 구한다
            vec3 relativePos = outputData[idx].Position.xyz - outputData[otherId].Position.xyz;
            float rSquare = dot(relativePos, relativePos);

            // 영향력 있는 거리 안이다
            if(rSquare < hSquare)
                newSurfNormal.xyz += particleMass / outputData[otherId].density * Grad_W_Poly6(rSquare) * relativePos;
        }


        // 우 검색
        for(uint otherId = idx + 1; otherId < particleCount; otherId++)
        {
            // 카메라에서 => 다른 파티클까지의 거리가, 나까지의 거리 + h 보다 크면, 그 이후부터는 무조건 멀다
            if(outputData[otherId].ToCamera > outputData[idx].ToCamera + h)
                break;

            // 두 파티클 사이의 거리를 구한다
            vec3 relativePos = outputData[idx].Position.xyz - outputData[otherId].Position.xyz;
            float rSquare = dot(relativePos, relativePos);

            // 영향력 있는 거리 안이다
            if(rSquare < hSquare)
                newSurfNormal.xyz += particleMass / outputData[otherId].density * Grad_W_Poly6(rSquare) * relativePos;
        }

    // threshold 보다 크면 표면 => 카운트 세고, 저장
    if(length(outputData[idx].surfNormal) > surfForceThreshold)
    {
        atomicAdd(count, 1);
        outputData[idx].surfNormal = newSurfNormal;
    }
    // 표면이 아니면, zero vector 를 넣자
    else
        outputData[idx].surfNormal = vec4(0.0, 0.0, 0.0, 0.0);
}


// 1. 주변에 영향을 받는 힘을 구한다
vec4 Get_Fluid_Force(uint idx)
{
    // 이번에 구하고자 하는 힘들
    vec4 PressureForce = vec4(0.0, 0.0, 0.0, 0.0);
    vec4 ViscosityForce = vec4(0.0, 0.0, 0.0, 0.0);
    float SurfaceForceMag = 0;


       
    // 좌 검색
    for(uint otherId = idx - 1; otherId >= 0; otherId--)
    {
        if(outputData[otherId].ToCamera < outputData[idx].ToCamera - h)
            break;


        // 논문의 내용을 그대로 적용 => 상대->나, 방향의 벡터를 사용한다
        vec4 relativePos = outputData[idx].Position - outputData[otherId].Position;
        float rSquare = dot(relativePos, relativePos);

        // 영향력 있는 거리 안이다
        if(rSquare < hSquare)
        {
            float rLength = length(relativePos);
            vec4 unitRelativePos = normalize(relativePos);

            /*
                압력에 의한 힘 계산
                => 서로를 밀어내는 힘
                따라서 상대에 의해서, 상대로부터 멀어져야 한다
            */
            //PressureForce += (-1) * particleMass * (outputData[idx].pressure + outputData[otherId].pressure) / (2 * outputData[otherId].density) * Grad_W_Spiky(rLength) * unitRelativePos;

            /* 
                점성에 의한 힘 계산
                서로를 당기는 힘
                내 particle 이 상대 particle 방향으로 이동해야 한다
                현재 입자에서 상대 입자의 속도 방향과 같은 방향을 가진다
            */
            ViscosityForce += viscosity * particleMass * (outputData[otherId].Velocity - outputData[idx].Velocity) / outputData[otherId].density * Laplace_W_Viscosity(rLength);

            /* 
                표면 장력 => 방향은 이미 구한 surf normal 방향
                그 크기를 구해야 한다
            */
            //SurfaceForceMag += particleMass / outputData[otherId].density * Laplace_W_Poly6(rSquare);
        }
    }


    // 동일한 논리로 우측을 조사한다
    for(uint otherId = idx + 1; otherId < particleCount; otherId++)
    {
        if(outputData[otherId].ToCamera > outputData[idx].ToCamera + h)
            break;

        // 논문의 내용을 그대로 적용 => 상대->나, 방향의 벡터를 사용한다
        vec4 relativePos = outputData[idx].Position - outputData[otherId].Position;
        float rSquare = dot(relativePos.xyz, relativePos.xyz);

        // 영향력 있는 거리 안이다
        if(rSquare < hSquare)
        {
            float rLength = length(relativePos.xyz);
            vec4 unitRelativePos = normalize(relativePos);

            /*
                압력에 의한 힘 계산
                => 서로를 밀어내는 힘
                따라서 상대에 의해서, 상대로부터 멀어져야 한다
            */
            //PressureForce += (-1) * particleMass * (outputData[idx].pressure + outputData[otherId].pressure) / (2 * outputData[otherId].density) * Grad_W_Spiky(rLength) * unitRelativePos;

            /* 
                점성에 의한 힘 계산
                서로를 당기는 힘
                내 particle 이 상대 particle 방향으로 이동해야 한다
                현재 입자에서 상대 입자의 속도 방향과 같은 방향을 가진다
            */
            ViscosityForce += viscosity * particleMass * (outputData[otherId].Velocity - outputData[idx].Velocity) / outputData[otherId].density * Laplace_W_Viscosity(rLength);

            /* 
                표면 장력 => 방향은 이미 구한 surf normal 방향
                그 크기를 구해야 한다
            */
            //SurfaceForceMag += particleMass / outputData[otherId].density * Laplace_W_Poly6(rSquare);
        }
    }


    // 표면이 아니다 == surf normal 이 0 벡터다 == 표면장력이 0 이다
    // vec4 SurfaceForce = ( length(outputData[idx].surfNormal) == 0 ) ? vec4(0.0, 0.0, 0.0, 0.0)
    //                     : (-1) * surfCoeffi * SurfaceForceMag * normalize(outputData[idx].surfNormal);


    //PressureForce *= pressureRatio;
    // ViscosityForce *= viscosityRatio;
    // SurfaceForce *= surfaceRatio;

    // 모든 힘을 리턴한다
    //return PressureForce + ViscosityForce + SurfaceForce;
    //return PressureForce;
    return ViscosityForce;
}



// 2. 주변 particle 에 관계없이 계산되는 힘
vec4 Get_Extra_Force(uint idx)
{
    vec4 ExtraForce = vec4(0, 0, 0, 0);
    float curDensity = outputData[idx].density;

    // 중력에 의한 힘
    // 나비에 스톡스 방정식에 의해 ~ 밀도 사용 // 나도 2000 정도 곱해줘야 하나??
    ExtraForce += gravityAcel * curDensity;



    return ExtraForce;
}


void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint Index = gl_GlobalInvocationID.x;

    // 0. surf normal 을 먼저 구한다
    Update_SurfNormal(Index);

    // 알짜힘 초기화
    outputData[Index].force = vec4(0.0, 0.0, 0.0, 0.0);

    // 1. 영향을 받는 힘을 구하고
    outputData[Index].force += Get_Fluid_Force(Index);

    // 2. 영향을 안 받는 힘을 구한다
    outputData[Index].force += Get_Extra_Force(Index);
}