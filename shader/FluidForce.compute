#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


// 넘겨받는 Uniform Variables{}
// 0
// Smooth Kernel 관련 정보
    uniform float h;
    uniform float hSquare;

    // Particles 에 대한 정보
    uniform float particleMass;
    uniform uint particleCount;

// 1
    // 점성에 의한 힘
    uniform float viscosity;

    // 표면 장력의 정도
    uniform float surfCoeffi;
    uniform float surfForceThreshold;

// 2 => Extra Force
    uniform vec3 gravityAcel;


    


    

    //smooth kernel 함수들 => 일단 함수로 쓰고, 나중에 MACRO 로 바꿔보자
    #define PI 3.1415
    /* 
        Grad_W_Poly6 -> r 제곱을 변수로 사용
                    -> gradient 결과 상대 particle 을 가리키는 벡터를 가진다
                    -> 이 함수는 크기만 계산
        사용처
            : surface normal filed pointing into the fluid 계산
    */
    float Grad_W_Poly6(float r2) { return (315.0 * (-6.0) / (64.0 * PI * pow(abs(h), 9))) * pow(abs(hSquare - r2), 2); }
    /* 
        Laplace_W_Poly6 -> r 제곱을 사용
        사용처
            : curvature of the surface 계산
    */
    float Laplace_W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9))) * ((-18) * pow(abs(hSquare - r2), 2) + 24 * r2 * (hSquare - r2)); }
    /* 
        Grad_W_Spiky -> r 을 사용
                    -> particle 에서 다른 particle 을 향하는 방향을 가진다 => normalized vector
                    -> 이 함수는 단위벡터를 제외한 크기만 계산
        사용처
            : 압력에 의한 힘 계산
    */
    float Grad_W_Spiky(float r) { return (-45.0 / ( PI * pow(abs(h), 6) )) * (pow(abs(h - r), 2)); }
    /* 
        Laplace_W_Viscosity -> r 사용
        사용처
            : 점성에 의한 힘 계산
    */
    float Laplace_W_Viscosity(float r) { return (45.0 / (PI * pow(abs(h), 6))) * (h - r); }





/* 
    Output Data 에서,
    position, velocity, density, pressure 는 계산이 완료된 상태

    force, surfNormal 을 구해서 넣어주어야 한다

    input data 가 그대로 output 으로 들어왔기 때문에, particles 는 여전히 정렬된 상태다
 */
struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 surfNormal;    // 0.
    float isSurf;       // 0.

    vec3 force;         // 1, 2s
    float toCamera;
};
layout(std430, binding = 2) buffer OutputBuffer
{
    Particle outputData[];
};

layout(std430, binding = 5) buffer TestBuffer
{
    uint count;
};



/* 
    force(알짜힘) + surfNormal 구하기
        0. 가장 먼저 surfNormal 을 구한다

        1. 주변 particles 의 값을 통해 구하는 값
            압력에 의한 힘
            점성에 의한 힘
            표면장력

        2. 주변과 관계없이 구할 수 있는 값
            wave
            중력
            클릭
 */


// surf normal, isSurf 계산
void Update_SurfNormal(uint idx)
{
    vec3 newSurfNormal = vec3(0.0, 0.0, 0.0);

    // range 범위를 조사, far->near
    for(uint id = outputData[idx].range.x; id <= outputData[idx].range.y; id++)
    {
        // 두 파티클 사이의 거리를 구한다
        vec3 relativePos = outputData[idx].position.xyz - outputData[id].position.xyz;
        float rSquare = dot(relativePos, relativePos);

        // 영향력 있는 거리 안이다
        if(rSquare < hSquare)
            newSurfNormal += particleMass / outputData[id].density * Grad_W_Poly6(rSquare) * relativePos;
            //newSurfNormal += vec3(1, 0, 0);
    }


    // 연산결과가 threshold 보다 크다 == It is Surface => 카운트 세고, particle 정보에 저장
    if(length(newSurfNormal) > surfForceThreshold)
    {
        atomicAdd(count, 1);
        outputData[idx].isSurf = 1.0f;
    }
    // 표면이 아니면, surface 가 아님을 기록
    else
        outputData[idx].isSurf = 0.0f;


    // surface normal 저장
    outputData[idx].surfNormal = newSurfNormal;
}


// force => 주변에 영향을 받는 힘을 구한다
void Get_Fluid_Force(uint idx)
{
    // 이번에 구하고자 하는 힘들
    vec3 PressureForce = vec3(0.0, 0.0, 0.0);
    vec3 ViscosityForce = vec3(0.0, 0.0, 0.0);
    float SurfaceForceMag = 0;


       
    // range 범위를 조사, far->near
    for(uint id = outputData[idx].range.x; id <= outputData[idx].range.y; id++)
    {
        // 논문의 내용을 그대로 적용 => 상대->나, 방향의 벡터를 사용한다
        vec3 relativePos = outputData[idx].position.xyz - outputData[id].position.xyz;
        float rSquare = dot(relativePos, relativePos);

        // 영향력 있는 거리 안이다
        if(rSquare < hSquare)
        {
            float rLength = length(relativePos);
            vec3 unitRelativePos = normalize(relativePos);

            /*
                압력에 의한 힘 계산
                => 서로를 밀어내는 힘
                따라서 상대에 의해서, 상대로부터 멀어져야 한다
            */
            PressureForce += (-1) * particleMass * (outputData[idx].pressure + outputData[id].pressure) / (2 * outputData[id].density) * Grad_W_Spiky(rLength) * unitRelativePos;

            /* 
                점성에 의한 힘 계산
                서로를 당기는 힘
                내 particle 이 상대 particle 방향으로 이동해야 한다
                현재 입자에서 상대 입자의 속도 방향과 같은 방향을 가진다
            */
            ViscosityForce += viscosity * particleMass * (outputData[id].velocity - outputData[idx].velocity).xyz / outputData[id].density * Laplace_W_Viscosity(rLength);

            /* 
                표면 장력 => 방향은 이미 구한 surf normal 방향
                그 크기를 구해야 한다

                표면에 대해서만 계산한다
            */
            if(outputData[idx].isSurf != 0.0f)
                SurfaceForceMag += particleMass / outputData[id].density * Laplace_W_Poly6(rSquare);
        }
    }


    // 표면장력
    vec3 SurfaceForce = ( outputData[idx].isSurf == 0.0f ) ? vec3(0.0, 0.0, 0.0)
                                                           : (-1) * surfCoeffi * SurfaceForceMag * normalize(outputData[idx].surfNormal);



    // 모든 힘을 저장한다
    outputData[idx].force = PressureForce + ViscosityForce + SurfaceForce;
}



// 2. 주변 particle 에 관계없이 계산되는 힘
void Get_Extra_Force(uint idx)
{
    vec3 ExtraForce = vec3(0, 0, 0);
    float curDensity = outputData[idx].density;

    // 중력에 의한 힘
    // 나비에 스톡스 방정식에 의해 ~ 밀도 사용 // 나도 2000 정도 곱해줘야 하나??
    ExtraForce += gravityAcel * curDensity;



    // 추가적인 힘을 더해 저장
    outputData[idx].force += ExtraForce;
}


void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint Index = gl_GlobalInvocationID.x;

    // 0. surf normal 을 먼저 구한다
    Update_SurfNormal(Index);

    // 1. 영향을 받는 힘을 구하고
    //Get_Fluid_Force(Index);

    // 2. 영향을 안 받는 힘을 구한다
    //Get_Extra_Force(Index);
}