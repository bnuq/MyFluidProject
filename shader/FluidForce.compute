#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


// Uniform Variables
// 0
// Smooth Kernel 관련 정보
    uniform float h;
    uniform float hSquare;

    // Particles 에 대한 정보
    uniform float particleMass;
    uniform uint particleCount;

// 1
    // 점성에 의한 힘
    uniform float viscosity;


// 2 => Extra Force
    uniform vec3 gravityAcel;


    


    

    //smooth kernel 함수들 => 일단 함수로 쓰고, 나중에 MACRO 로 바꿔보자
    #define PI 3.1415
    /* 
        Grad_W_Poly6 -> r 제곱을 변수로 사용
                    -> gradient 결과 상대 particle 을 가리키는 벡터를 가진다
                    -> 이 함수는 크기만 계산
        사용처
            : surface normal filed pointing into the fluid 계산
    */
    float Grad_W_Poly6(float r2) { return (315.0 * (-6.0) / (64.0 * PI * pow(abs(h), 9))) * pow(abs(hSquare - r2), 2); }
    /* 
        Laplace_W_Poly6 -> r 제곱을 사용
        사용처
            : curvature of the surface 계산
    */
    float Laplace_W_Poly6(float r2) { return (315.0 / (64 * PI * pow(abs(h), 9))) * ((-18) * pow(abs(hSquare - r2), 2) + 24 * r2 * (hSquare - r2)); }
    /* 
        Grad_W_Spiky -> r 을 사용
                    -> particle 에서 다른 particle 을 향하는 방향을 가진다 => normalized vector
                    -> 이 함수는 단위벡터를 제외한 크기만 계산
        사용처
            : 압력에 의한 힘 계산
    */
    float Grad_W_Spiky(float r) { return (-45.0 / ( PI * pow(abs(h), 6) )) * (pow(abs(h - r), 2)); }
    /* 
        Laplace_W_Viscosity -> r 사용
        사용처
            : 점성에 의한 힘 계산
    */
    float Laplace_W_Viscosity(float r) { return (45.0 / (PI * pow(abs(h), 6))) * (h - r); }





/*
    여전히 정렬된 배열 ParticleBuffer
        파티클 ~ 카메라 거리, toCamera 값으로 정렬
        Far -> Near 순서로 정렬

    position;                   position

    velocity;                   velocity

    range                       range
    density                     density
    pressure                    pressure

    -               =>          force               , = pressure force + viscosity force (Update_Fluid_Force)
                                                      + extra force                      (Update_Extra_Force)

    toCamera;                   toCamera
 */

struct Particle
{
    vec4 position;

    vec4 velocity;

    uvec2 range;
    float density;
    float pressure;

    vec3 force;
    float toCamera;
};


layout(std430, binding = 1) buffer ParticleBuffer
{
    Particle pData[];
};



// force => 주변에 영향을 받는 힘을 구한다
void Update_Fluid_Force(uint myId)
{
    // 이번에 구하고자 하는 힘들
    vec3 PressureForce = vec3(0.0, 0.0, 0.0);
    vec3 ViscosityForce = vec3(0.0, 0.0, 0.0);


       
    // range 범위를 조사, far->near
    for(uint neId = pData[myId].range.x; neId <= pData[myId].range.y; neId++)
    {
        // 논문의 내용을 그대로 적용 => 상대->나, 방향의 벡터를 사용한다
        vec3 relativePos = pData[myId].position.xyz - pData[neId].position.xyz;
        float rSquare = dot(relativePos, relativePos);

        // 영향력 있는 거리 안이다 + 자기 자신에 대한 연산은 제외한다 => normalize 에서 에러 발생
        if(rSquare != 0 && rSquare < hSquare)
        {
            float rLength = length(relativePos);
            vec3 unitRelativePos = normalize(relativePos);

            /*
                압력에 의한 힘 계산
                => 서로를 밀어내는 힘
                따라서 상대에 의해서, 상대로부터 멀어져야 한다
            */
            PressureForce += (-1) * particleMass * (pData[myId].pressure + pData[neId].pressure) / (2 * pData[neId].density) * Grad_W_Spiky(rLength) * unitRelativePos;

            /* 
                점성에 의한 힘 계산
                서로를 당기는 힘
                내 particle 이 상대 particle 방향으로 이동해야 한다
                현재 입자에서 상대 입자의 속도 방향과 같은 방향을 가진다
            */
            ViscosityForce += viscosity * particleMass * (pData[neId].velocity.xyz - pData[myId].velocity.xyz) / pData[neId].density * Laplace_W_Viscosity(rLength);
        }
    }

    // 모든 힘을 저장한다
    pData[myId].force += (PressureForce + ViscosityForce);
}



// 2. 주변 particle 에 관계없이 계산되는 힘
void Update_Extra_Force(uint myId)
{
    vec3 ExtraForce = vec3(0, 0, 0);
    float curDensity = pData[myId].density;

    // 중력에 의한 힘
    // 나비에 스톡스 방정식에 의해 ~ 밀도 사용 // 나도 2000 정도 곱해줘야 하나??
    ExtraForce += gravityAcel * curDensity;



    // 추가적인 힘을 더해 저장
    pData[myId].force += ExtraForce;
}


void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint index = gl_GlobalInvocationID.x;

    // force 초기화
    pData[index].force = vec3(0.0, 0.0, 0.0);

    // 1. 영향을 받는 힘을 구하고
    Update_Fluid_Force(index);

    // 2. 영향을 안 받는 힘을 구한다
    Update_Extra_Force(index);
}