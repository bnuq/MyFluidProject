#version 460 core

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;


// depth map
uniform sampler2D depthMap;             // 카메라에서 본, 깊이 맵

uniform mat4 transform;                 // 월드 -> 카메라 클립 공간 변환

uniform float offset;                   // particle 와 텍스처의 깊이를 비교할 값


struct CoreParticle
{
    float xpos;
    float ypos;
    float zpos;

    float xvel;
    float yvel;
    float zvel;

    float toCamera;

    uint visible;
};
layout(std430, binding = 1) buffer CoreParticleBuffer
{
    CoreParticle cData[];
};



layout(std430, binding = 5) buffer CountBuffer
{
    uint count;
};


void main()
{
    // ssbo 에 접근하는 스레드의 인덱스
    uint index = gl_GlobalInvocationID.x;


    // Core Particle 의 중심점이, 카메라 클립 공간으로 변환됐다고 가정했을 때
    // 카메라 클립 공간 내에서의 좌표
    vec4 ClipPos = transform * vec4(cData[index].xpos, cData[index].ypos, cData[index].zpos, 1.0);

    // 클립 공간 좌표로 부터, depth map 의 텍스처 좌표를 얻을 수 있다
    vec3 depthMapCoord = ClipPos.xyz / ClipPos.w;
    depthMapCoord = depthMapCoord * 0.5 + 0.5;


    float closestDepth = texture(depthMap, depthMapCoord.xy).r;
    float currentDepth = depthMapCoord.z;


    /* 
        depth map 에는 앞면만 남으니까
        particle 의 위치보다 조금 더 앞선 fragment 만 남게 된다
        따라서
        일단 closestDepth < currentDepth 이고
        currentDepth - closestDepth 가 offset 보다 작으면 visible 하다고 하자
     */

    if(closestDepth < currentDepth &&
       currentDepth - closestDepth < offset)
    {
        cData[index].visible = 1;
        atomicAdd(count, 1);
    }
    else
        cData[index].visible = 0;
}